#!/usr/bin/env python3

#
# gssh - run a single command on multiple servers at once
# Copyright (C) 2014-2017 Bozhin Zafirov <bozhin@deck17.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#

import argparse
import io
import subprocess
import sys
import time
import configparser
import asyncio

# templates
Template = '%*s%s \033[01;32m->\033[0m %s'
ErrTemplate = '%*s%s \033[01;31m=>\033[0m %s'
if not sys.stdout.isatty():
    Template = '%*s%s -> %s'
    ErrTemplate = '%*s%s => %s'


# print group progress in a status line
class ScreenProgress(object):
    # class constructor
    def __init__(self) -> None:
        self.active = 0
        self.total = 0
        self.complete = 0

        self.max_hostname_len = 0

    # clear status line
    @staticmethod
    def clear() -> None:
        sys.stderr.write('\r%*s\r' % (41, ' '))

    # print a new status line
    def status(self):
        sys.stderr.write(
            '[%d/%d] %.2f%% complete, %d active' % (
                self.complete,
                self.total,
                float(self.complete) * float(100.0) / float(self.total),
                self.active))

    # update progress line on stderr
    def update(self) -> None:
        self.clear()
        self.status()
        sys.stderr.flush()

    # print server message to stdout
    def print_output(self, out_dev: io.BufferedWriter, template: str, address: str, line: str) -> None:
        self.clear()
        out_dev.write(
            template % (
                self.max_hostname_len - len(address),
                ' ',
                address,
                line))
        self.status()
        out_dev.flush()
        if out_dev != sys.stderr:
            sys.stderr.flush()

    # start a new process
    def start(self, hostname: str) -> None:
        if len(hostname) + 1 > self.max_hostname_len:
            self.max_hostname_len = len(hostname) + 1

    # update stats at process stop
    def stop(self) -> None:
        with self.lock:
            self.active -= 1
            self.complete += 1
            self.update()


readers = 0

# ssh server
class SshServer(object):
    def __init__(self, progress: ScreenProgress, username: str, address: str, command: str,
                 no_strict: bool = False) -> None:
        self.progress = progress
        self.username = username
        self.address = address
        self.command = command
        self.no_strict = no_strict

        # stats
        self.stdout_lines = 0
        self.stderr_lines = 0

        super(SshServer, self).__init__()

        # update process stats
        self.progress.start(self.address)

    # run the process
    def run(self, loop) -> None:
        strict_checking = 'StrictHostKeyChecking=yes'
        if self.no_strict:
            strict_checking = 'StrictHostKeyChecking=no'

        # start subprocess
        cmd = subprocess.Popen([
            'env',
            'ssh',
            '-A',
            '-o', 'PasswordAuthentication=no',
            '-o', strict_checking,
            '-o', 'GSSAPIAuthentication=no',
            '-o', 'HostbasedAuthentication=no',
            '-l', self.username,
            self.address,
            self.command],

            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=False)


        def get_reader(fd, stdout=True):
            global readers
            readers += 1

            def reader(*args):
                global readers
                line = str()
                while True:
                    line = fd.readline()
                    if not line:
                        loop.remove_reader(fd)
                        readers -= 1
                        if not readers:
                            loop.stop()
                        break
                    if stdout:
                        self.progress.print_output(sys.stdout, Template, self.address, line.decode())
                        self.stdout_lines += 1
                    else:
                        self.progress.print_output(sys.stderr, ErrTemplate, self.address, line.decode())
                        self.stderr_lines += 1

            return reader

        global readers
        loop.add_reader(cmd.stdout, get_reader(cmd.stdout, True))
        loop.add_reader(cmd.stderr, get_reader(cmd.stderr, False))


# group ssh servers to a single object
class SshGroup(object):
    # class constructor
    def __init__(self, _args) -> None:
        self.args = _args
        self.servers = []
        self.progress = ScreenProgress()

    # start ssh command
    def command(self, username: str, address: str, command: str) -> None:
        ssh = SshServer(self.progress, username, address, command, self.args.no_strict)
        self.servers.append(ssh)
        self.progress.total += 1

    # start threads
    def start(self, delay: int = 100, processes: int = 500) -> None:
        loop = asyncio.get_event_loop()
        for s in self.servers:
            s.run(loop)
            time.sleep(float(delay) / 1000.0)
        loop.run_forever()


# main program
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--delay', default=100, type=int,
                        help='delay in milliseconds between each ssh fork (default 100)')
    parser.add_argument('-f', '--file', default=sys.stdin, type=argparse.FileType('r'),
                        help='file with the list of hosts (default: read from stdin)')
    parser.add_argument('-p', '--processes', default=500, type=int,
                        help='number of parallel ssh processes (default: 500)')
    parser.add_argument('-n', '--no-strict', default=False, action='store_true',
                        help='disable strict ssh fingerprint checking')
    parser.add_argument('-u', '--user', default='root', type=str, help='ssh login as this username')
    parser.add_argument('-a', '--ansible', default=False, action='store_true',
                        help='read ansible hosts file at /etc/ansible/hosts')
    parser.add_argument('-s', '--section', default=None, type=str,
                        help='name of ansible ini section containing servers list')
    parser.add_argument('command', type=str, help='the actual command to run on servers')
    args = parser.parse_args()

    # ssh group instance
    group = SshGroup(args)

    # parse servers list
    servers_list = []
    if args.ansible:
        config = configparser.ConfigParser(strict=False, allow_no_value=True)
        config.read('/etc/ansible/hosts')
        for section in config.sections():
            if args.section and section != args.section:
                continue
            servers_list.extend([line.split()[0] for line in config.options(section)])
    else:
        servers_list = [server.strip() for server in args.file if server and not server.startswith('#')]

    for server in servers_list:
        group.command(args.user, server, args.command)

    sys.stderr.write('gssh - group ssh, ver. 1.2\n')
    sys.stderr.write('(c)2014-2018 Bozhin Zafirov <bozhin@deck17.com>\n')
    sys.stderr.write('\n')
    sys.stderr.write('  [*] read (%d) hosts from the list\n' % len(group.servers))
    sys.stderr.write('  [*] executing \'%s\' as user \'%s\'\n' % (args.command, args.user))
    sys.stderr.write('  [*] spawning %d parallel ssh sessions\n\n' % min((args.processes, len(group.servers))))
    sys.stderr.flush()

    # start processes
    group.start(args.delay, args.processes)

    # print stats
    group.progress.clear()
    sys.stderr.write(
        '\n  Done. Processed: %d / Output: %d (%d) / \033[01;32m->\033[0m %d (%d) / \033[01;31m=>\033[0m %d (%d)\n' % (
            len(group.servers),
            len(list(filter(lambda x: x.stdout_lines or x.stderr_lines, group.servers))),
            sum(map(lambda x: x.stdout_lines + x.stderr_lines, group.servers)),
            len(list(filter(lambda x: x.stdout_lines, group.servers))),
            sum(map(lambda x: x.stdout_lines, group.servers)),
            len(list(filter(lambda x: x.stderr_lines, group.servers))),
            sum(map(lambda x: x.stderr_lines, group.servers)),
        ))
    sys.stderr.flush()
