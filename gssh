#!/usr/bin/env python3

#
# gssh - run a single command on multiple servers at once
# Copyright (C) 2014-2018 Bozhin Zafirov <bozhin@deck17.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software Foundation,
#   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
#

import argparse
import asyncio
import configparser
import subprocess
import sys
import time

# templates
Template = '%*s%s \033[01;32m->\033[0m %s'
ErrTemplate = '%*s%s \033[01;31m=>\033[0m %s'
if not sys.stdout.isatty():
    Template = '%*s%s -> %s'
    ErrTemplate = '%*s%s => %s'


# print group progress in a status line
class ScreenProgress(object):
    # namespace variables
    max_hostname_len = 0
    active = 0
    complete = 0
    total = 0

    # class constructor
    def __init__(self) -> None:
        self.stdout_lines = 0
        self.stderr_lines = 0

    # clear status line
    @staticmethod
    def clear() -> None:
        sys.stderr.write('\r%*s\r' % (41, ' '))

    # print a new status line
    def status(self):
        sys.stderr.write(
            '[%d/%d] %.2f%% complete, %d active' % (
                self.complete,
                ScreenProgress.total,
                float(ScreenProgress.complete) * float(100.0) / float(ScreenProgress.total),
                ScreenProgress.active))

    # update progress line on stderr
    def update(self) -> None:
        self.clear()
        self.status()
        sys.stderr.flush()

    # print server message to stdout
    def print_output(self, address: str, line: str, stdout: bool = True) -> None:
        self.clear()
        if stdout:
            output_fd = sys.stdout
            template = Template
            self.stdout_lines += 1
        else:
            output_fd = sys.stderr
            template = ErrTemplate
            self.stderr_lines += 1

        output_fd.write(
            template % (
                ScreenProgress.max_hostname_len - len(address),
                ' ',
                address,
                line))
        self.status()
        output_fd.flush()
        if output_fd != sys.stderr:
            sys.stderr.flush()

    # start a new process
    @staticmethod
    def start(hostname: str) -> None:
        if len(hostname) + 1 > ScreenProgress.max_hostname_len:
            ScreenProgress.max_hostname_len = len(hostname) + 1

    # update stats at process stop
    def stop(self) -> None:
        ScreenProgress.active -= 1
        ScreenProgress.complete += 1
        self.update()


def reader_generator():
    data = dict(readers=0)

    def do_get_reader(fd, loop: asyncio.BaseEventLoop, progress: ScreenProgress, address: str, stdout=True):
        data['readers'] += 1

        def reader(*_args):
            while True:
                line = fd.readline()
                if not line:
                    loop.remove_reader(fd)
                    if data['readers'] % 2 == 0:
                        progress.stop()
                    data['readers'] -= 1
                    if not data['readers']:
                        loop.stop()
                    break
                if stdout:
                    progress.print_output(address, line.decode(), stdout=True)
                else:
                    progress.print_output(address, line.decode(), stdout=False)

        return reader

    return do_get_reader


class SshServer(ScreenProgress):
    """SSH Server object"""

    def __init__(self, username: str, address: str, command: str,
                 no_strict: bool = False) -> None:
        """Class constructor"""
        self.username = username
        self.address = address
        self.command = command
        self.no_strict = no_strict
        ScreenProgress.total += 1
        # update process stats
        super(SshServer, self).__init__()
        self.start(self.address)

    def run(self, loop) -> None:
        """Fork a background process and attach readers to asyncio event loop"""
        strict_checking = 'StrictHostKeyChecking=yes'
        if self.no_strict:
            strict_checking = 'StrictHostKeyChecking=no'
        # start subprocess
        cmd = subprocess.Popen(
            [
                'env',
                'ssh',
                '-A',
                '-o', 'PasswordAuthentication=no',
                '-o', strict_checking,
                '-o', 'GSSAPIAuthentication=no',
                '-o', 'HostbasedAuthentication=no',
                '-l', self.username,
                self.address,
                self.command,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=False,
        )
        # create readers for subprocess stdin and stdout and attach to event loop
        loop.add_reader(cmd.stdout, get_reader(cmd.stdout, loop, self, self.address, True))
        loop.add_reader(cmd.stderr, get_reader(cmd.stderr, loop, self, self.address, False))


class SshGroup(object):
    """SSH Servers Group object"""

    def __init__(self, _args) -> None:
        """Class constructor"""
        self.args = _args
        self.servers = []

    def command(self, username: str, address: str, command: str) -> None:
        """Start ssh command"""
        ssh = SshServer(username, address, command, self.args.no_strict)
        self.servers.append(ssh)

    def init_servers(self, loop, delay: int = 100, processes: int = 500):
        """Gradually fork background workers by keeping their number below processes value"""
        float_delay = float(delay) / 1000.0
        for server in self.servers:
            while ScreenProgress.active > processes:
                time.sleep(float_delay)
            server.run(loop)
            time.sleep(float_delay)
            ScreenProgress.active += 1

    def start(self, delay: int = 100, processes: int = 500) -> None:
        """Start asyncio loop"""
        loop = asyncio.get_event_loop()
        loop.call_soon(self.init_servers, loop, delay, processes)
        loop.run_forever()
        loop.close()


# main program
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--delay', default=100, type=int,
                        help='delay in milliseconds between each ssh fork (default 100)')
    parser.add_argument('-f', '--file', default=sys.stdin, type=argparse.FileType('r'),
                        help='file with the list of hosts (default: read from stdin)')
    parser.add_argument('-p', '--processes', default=500, type=int,
                        help='number of parallel ssh processes (default: 500)')
    parser.add_argument('-n', '--no-strict', default=False, action='store_true',
                        help='disable strict ssh fingerprint checking')
    parser.add_argument('-u', '--user', default='root', type=str, help='ssh login as this username')
    parser.add_argument('-a', '--ansible', default=False, action='store_true',
                        help='read ansible hosts file at /etc/ansible/hosts')
    parser.add_argument('-s', '--section', default=None, type=str,
                        help='name of ansible ini section containing servers list')
    parser.add_argument('command', type=str, help='the actual command to run on servers')
    args = parser.parse_args()

    # ssh group instance
    group = SshGroup(args)
    get_reader = reader_generator()

    # parse servers list
    servers_list = []
    if args.ansible:
        config = configparser.ConfigParser(strict=False, allow_no_value=True)
        config.read('/etc/ansible/hosts')
        for section in config.sections():
            if args.section and section != args.section:
                continue
            servers_list.extend([line.split()[0] for line in config.options(section)])
    else:
        servers_list = [server.strip() for server in args.file if server and not server.startswith('#')]

    for server in servers_list:
        group.command(args.user, server, args.command)

    sys.stderr.write('gssh - group ssh, ver. 1.2\n')
    sys.stderr.write('(c)2014-2018 Bozhin Zafirov <bozhin@deck17.com>\n')
    sys.stderr.write('\n')
    sys.stderr.write('  [*] read (%d) hosts from the list\n' % len(group.servers))
    sys.stderr.write('  [*] executing \'%s\' as user \'%s\'\n' % (args.command, args.user))
    sys.stderr.write('  [*] spawning %d parallel ssh sessions\n\n' % min((args.processes, len(group.servers))))
    sys.stderr.flush()

    # start processes
    group.start(args.delay, args.processes)

    # print stats
    ScreenProgress.clear()
    sys.stderr.write(
        '\n  Done. Processed: %d / Output: %d (%d) / \033[01;32m->\033[0m %d (%d) / \033[01;31m=>\033[0m %d (%d)\n' % (
            len(group.servers),
            len(list(filter(lambda x: x.stdout_lines or x.stderr_lines, group.servers))),
            sum(map(lambda x: x.stdout_lines + x.stderr_lines, group.servers)),
            len(list(filter(lambda x: x.stdout_lines, group.servers))),
            sum(map(lambda x: x.stdout_lines, group.servers)),
            len(list(filter(lambda x: x.stderr_lines, group.servers))),
            sum(map(lambda x: x.stderr_lines, group.servers)),
        ))
    sys.stderr.flush()
